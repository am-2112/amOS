#ifndef FAT32_H
#define FAT32_H

#include "efi.h"
#include "PartitionInterface.h"
#include "FileSystemInterface.h"
#include "std.h"

extern void ConstructGenericFromFAT32(GENERIC_PARTITION *partition, GENERIC_FILESYSTEM **out);

#pragma pack(1)

/*generic bpb struct for all fat types*/
typedef struct _BPB_FAT_COMMON
{
	uint8_t BS_jmpBoot[3];
	uint8_t BS_OEMName[8];

	uint16_t BPB_BytesPerSec; /*should be the same as for block_io protocol*/
	uint8_t BPB_SecPerClus;	  /*number of sectors per allocation unit*/
	uint16_t BPB_RsvdSecCnt;  /*number of reserved sectors starting at first sector of volume (to align start of data area / cluster #2)*/

	uint8_t BPB_Num_FATs;
	uint16_t BPB_RootEntCnt; /*count of 32-byte directory entries in root directory (must be 0 for FAT32)*/
	uint16_t BPB_TotSec16;	 /*if 0, BPB_TotSec32 must be non-zero (must be 0 for FAT32)*/

	uint8_t BPB_Media; /*0xF8 standard for non-removable; 0xF0 often for removable media*/

	uint16_t BPB_FATSz16; /*must be 0 for FAT32*/

	uint16_t BPB_SecPerTrk; /*sectors per track for interrupt 0x13 (only relevant for media that have geometry - volume broken into tracks by multiple heads and cylinders - and visible on interrupt 0x13)*/
	uint16_t BPB_NumHeads;	/*number of heads for interrupt 0x13 (see above)*/
	uint32_t BPB_HiddSec;	/*generally only relevant for media on interrupt 0x13 (count of hidden sectors preceding the partition containing this FAT volume)*/

	uint32_t BPB_TotSec32; /*new 32-bit total count of sectors on the volume (including count of all sectors in all 4 regions of the volume) - non-zero for FAT32*/
} BPB_FAT_COMMON;

typedef struct _BPB_FAT_16_12
{
	uint8_t BS_DrvNum; /*interrupt 0x13 drive number (set value to 0x80 or 0x00)*/
	uint8_t BS_Reserved1;

	uint8_t BS_BootSig;		  /*extended boot signature (0x29 if either of following fields are non-zero; indicates that the following 3 fields in the boot sector are present)*/
	uint32_t BS_VolID;		  /*volume serial number (in tandem with BS_VolLab, supports volume tracking on removable media); generated by combining current date & time into 32-bit value*/
	uint8_t BS_VolLab[11];	  /*volume label (matches label recorded in root directory)*/
	uint8_t BS_FilSysType[8]; /*set to string "FAT32  \0"*/

	uint8_t _[448];
} BPB_FAT_16_12;

/*Microsoft FAT32 boot sector spans 3 sectors; with BPB on the first sector of the partition*/
typedef struct _BPB_FAT_32
{
	uint32_t BPB_FATSz32;  /*32-bit count of sectors occupied by one FAT (File Allocation Table)*/
	uint16_t BPB_ExtFlags; /*Bits 0-3: Zero-based number of active FAT; Bits 7 -> 0: FAT is mirrored at runtime into all FATs (ignore bits 0-3) -> 1: only 1 FAT active (ref in bits 0-3)*/
	uint16_t BPB_FSVer;
	uint32_t BPB_RootClus;	/*cluster number of first cluster of root directory (2, or the first usable (not bad) cluster available after)*/
	uint16_t BPB_FSInfo;	/*sector number of FSINFO structure in reserved area of volume (usually 1); only the FSINFO copy pointed to by this field is kept up to date (both primary & backup boot record point to same FSINFO sector)*/
	uint16_t BPB_BkBootSec; /*0 or 6, points to copy of boot record (backup)*/
	uint32_t BPB_Reserved[3];

	uint8_t BS_DrvNum; /*interrupt 0x13 drive number (set value to 0x80 or 0x00)*/
	uint8_t BS_Reserved1;

	uint8_t BS_BootSig;		  /*extended boot signature (0x29 if either of following fields are non-zero; indicates that the following 3 fields in the boot sector are present)*/
	uint32_t BS_VolID;		  /*volume serial number (in tandem with BS_VolLab, supports volume tracking on removable media); generated by combining current date & time into 32-bit value*/
	uint8_t BS_VolLab[11];	  /*volume label (matches label recorded in root directory)*/
	uint8_t BS_FilSysType[8]; /*set to string "FAT32  \0"*/

	uint8_t _[420];
} BPB_FAT_32;

typedef struct _BPB_FAT
{
	BPB_FAT_COMMON common;
	union
	{
		BPB_FAT_32 fat32;
		BPB_FAT_16_12 fat16_12;
	};
	uint16_t Signature_word; /*set to 0x55AA*/
} BPB_FAT;

/*advisory information (must be validated at volume mount and maintained in memory by file system driver)*/
typedef struct _FSInfo
{
	uint32_t FSI_LeadSig; /*value = 0x41615252*/
	uint8_t FSI_Reserved1[480];
	uint32_t FSI_StructSig; /*value = 0x61417272*/

	uint32_t FSI_Free_Count; /*last known free cluster count*/
	uint32_t FSI_Nxt_Free;	 /*cluster number of first available (free) cluster on volume (unless value 0xFFFFFFFF)*/

	uint8_t FSI_Reserved2[12];
	uint32_t FSI_TrailSig; /*value = 0xAA550000*/
} FSInfo;

#define ATTR_READ_ONLY 0x01;
#define ATTR_HIDDEN 0x02;
#define ATTR_SYSTEM 0x04;
#define ATTR_VOLUME_ID 0x08; /*corresponding entry contains volume label (DIR_FstClus must be 0 for corresponding entry; since no clusters allocated for this entry); only root directory can contain one entry with this attribute (except ATTR_LONG_NAME since that includes this)*/
#define ATTR_DIRECTORY 0x10;
#define ATTR_ARCHIVE 0x20; /*Set when file is created, renamed, or modified (indicates properties of associated file has been modified - so that backup utilities can determine set of files that need to be backed up for protection)*/
#define ATTR_LONG_NAME (ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID);

typedef uint16_t FAT_DATE; /*Represents date where bits 0->4 represent day; 5->8 represent month; 9->15 represent years from 1980 inclusive (so cap of 2107)*/
typedef uint16_t FAT_TIME; /*Timestamps with granularity of 2 seconds; bhits 0->4 contain elapsed seconds (0..29 for 0..58 seconds); 5->10 contain number of minutes (0..59); 11->15 represent hours (0..23)*/

/*FAT Directories are a special file type serving as container for other files and sub-directories.
Directory contents (data) are a series of 32-byte directory entries (representing a contained file or sub-directory directory)*/
typedef struct _FAT_DIR_ENTRY
{
	/*using 8.3 method (8-char main part & 3 char extension; with implied '.' not stored, and 0x20 trailing spaces padding both components if required) (eg. "Pickle.a" -> "PICKLE A " or prettybg.big ->"PRETTYBGBIG" or ".big" -> "        BIG")
	 * DIR_Name[0] = 0xE5 indicates directory entry is free (the value 0x05 is used to represent 0xE5 if character set is KANJI since 0xE5 is valid KANJI lead byte value - in which case, appropriate substitution should occur in memory)
	 * DIR_Name[0] = 0x00 indicates all directory entries following the current (also free) entry is also free
	 * DIR_Name cannot start with 0x20 (ie. not start with space); and all names in directory must be unique
	 * Lowercase characters not allowed, values < 0x20 (except 0x05), and values 0x22 0x2A->0x2F 0x3A->0x3F 0x5B->0x5D and 0x7C are illegal values
	 * Following special characters allowed: $ % ' - _ @ ~ ` ! ( ) { } ^ # &
	 */
	uint8_t DIR_Name[11];
	uint8_t DIR_Attr; /*upper two bits are not to be interpreted*/

	uint8_t DIR_NTRes; /*reserved*/

	uint8_t DIR_CrtTimeTenth; /*component of file creation time (count of tenths of a second 0 <= DIR_CrtTimeTenth <= 199)*/
	FAT_TIME DIR_CrtTime;	  /*creation time (granularity of 2 seconds)*/
	FAT_DATE DIR_CrtDate;	  /*Creation Date*/
	FAT_DATE DIR_LstAccDate;  /*Last access date defined as a read/write operation performed on file/directory described by this entry*/

	uint16_t DIR_FstClusHI; /*high word of first data cluster number for file/directory described by this entry (only for FAT32)*/

	FAT_TIME DIR_WrtTime; /*must be appropriately updated*/
	FAT_DATE DIR_WrtDate; /*must be appropriately updated*/

	uint16_t DIR_FstClusLO; /*low word of first data cluster number for file/directory described by this entry*/

	uint32_t DIR_FileSize; /*max file size is 0xFFFFFFFF bytes; any chain of clusters allocated to file must be <= 0x100000000 bytes (last byte in such a chain cannot be part of file); max valid directory size is 2^21 bytes*/
} FAT_DIR_ENTRY;

#pragma pack()

/*0x00: free cluster (all clusters past the first free one should all be free too); 0x02 to MAX: allocated cluster (0xFFFFFF7: bad cluster; 0xFFFFFFFF: eof)
The first two entries in the FAT are reserved
*/
typedef uint32_t FAT32_ENTRY;
typedef uint16_t FAT16_ENTRY;

typedef uint16_t WORD;
typedef uint32_t DWORD;

#endif